//! Symbol types can be used to parameterize grammars.

use std::convert::{From, Into};
use std::hash::Hash;

pub use self::implt::NumericSymbol;
use self::implt::NumericSymbolRepr;

/// A type that can represent symbols in a context-free grammar. Symbols are distinguished by their
/// IDs.
pub trait GrammarSymbol: From<u64> + Into<u64> + Eq + Ord + Clone + Hash + Copy {
    /// Cast the symbol's ID to `usize`.
    #[inline]
    fn usize(&self) -> usize {
        let id: u64 = (*self).into();
        id as usize
    }
}

impl GrammarSymbol for NumericSymbol {}

/// A source of symbols.
pub trait SymbolSource {
    /// The type of symbols generated by this source.
    type Symbol: GrammarSymbol;

    /// Generates a new unique symbol.
    fn next_sym(&mut self) -> Self::Symbol;
    /// Returns the number of symbols in use.
    fn num_syms(&self) -> usize;
    /// Returns generated terminal symbols.
    fn sym<T>(&mut self) -> T
        where Self: Sized,
              T: SymbolContainer<Self::Symbol>
    {
        T::generate(self)
    }
    /// Returns an iterator that generates symbols.
    fn generate(&mut self) -> Generate<&mut Self> {
        Generate { source: self }
    }
}

impl<'a, S> SymbolSource for &'a mut S where S: SymbolSource
{
    type Symbol = S::Symbol;

    fn next_sym(&mut self) -> Self::Symbol {
        (**self).next_sym()
    }
    fn num_syms(&self) -> usize {
        (**self).num_syms()
    }
}

/// Iterator for generating terminal symbols.
pub struct Generate<S> {
    source: S,
}

impl<S> Iterator for Generate<S> where S: SymbolSource
{
    type Item = S::Symbol;

    fn next(&mut self) -> Option<Self::Item> {
        Some(self.source.next_sym())
    }
}

/// A source of numeric symbols.
#[derive(Clone, Copy, Debug)]
pub struct ConsecutiveSymbols {
    next_sym: NumericSymbolRepr,
}

/// The first usable symbol ID.
const FIRST_SYMBOL: u32 = 1;

impl ConsecutiveSymbols {
    /// Creates a source of numeric symbols with an empty symbol space.
    pub fn new() -> Self {
        ConsecutiveSymbols { next_sym: FIRST_SYMBOL }
    }

    /// Returns generated terminal symbols.
    pub fn sym<T>(&mut self) -> T
        where T: SymbolContainer<NumericSymbol>
    {
        T::generate(self)
    }
}

impl SymbolSource for ConsecutiveSymbols {
    type Symbol = NumericSymbol;

    fn next_sym(&mut self) -> NumericSymbol {
        let ret = NumericSymbol::from(self.next_sym as u64);
        self.next_sym = self.next_sym.saturating_add(1);
        ret
    }

    fn num_syms(&self) -> usize {
        self.next_sym as usize
    }
}

/// Trait used to generate terminal symbols.
pub trait SymbolContainer<S: GrammarSymbol> {
    /// Generates 
    fn generate<Ss>(source: Ss) -> Self where Ss: SymbolSource<Symbol = S>;
}

macro_rules! impl_generate {
    (S $(, $t:ident)*) => (
        impl<S> SymbolContainer<S> for ( S $(, $t)* ) where S: GrammarSymbol {
            fn generate<Ss>(mut source: Ss) -> Self where Ss: SymbolSource<Symbol=S> {
                ({ let x: S = source.next_sym(); x }
                 $(, { let x: $t = source.next_sym(); x })*)
            }
        }
        impl_generate!($($t),*);
    );
    // base case
    () => {}
}

impl_generate!(S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S);

#[cfg(not(feature = "nightly"))]
mod implt {
    pub type NumericSymbolRepr = u32;

    /// A common grammar symbol type.
    #[derive(Clone, Copy, Debug, Hash, Eq, Ord, PartialEq, PartialOrd)]
    pub struct NumericSymbol(NumericSymbolRepr);

    impl From<u64> for NumericSymbol {
        #[inline]
        fn from(id: u64) -> Self {
            NumericSymbol(id as NumericSymbolRepr)
        }
    }

    impl Into<u64> for NumericSymbol {
        #[inline]
        fn into(self) -> u64 {
            self.0 as u64
        }
    }
}

#[cfg(feature = "nightly")]
mod implt {
    use core::nonzero::NonZero;

    pub type NumericSymbolRepr = u32;

    /// A common grammar symbol type.
    #[derive(Clone, Copy, Debug, Hash, Eq, Ord, PartialEq, PartialOrd)]
    pub struct NumericSymbol(NonZero<NumericSymbolRepr>);

    impl From<u64> for NumericSymbol {
        #[inline]
        fn from(id: u64) -> Self {
            unsafe { NumericSymbol(NonZero::new(id as NumericSymbolRepr)) }
        }
    }

    impl Into<u64> for NumericSymbol {
        #[inline]
        fn into(self) -> u64 {
            *self.0 as u64
        }
    }
}
