var searchIndex = {};
searchIndex["cfg"] = {"doc":"Library for manipulations on context-free grammars. Most transformations are abstracted over\ngrammar representations.","items":[[3,"Cfg","cfg","Basic representation of context-free grammars.",null,null],[3,"Symbol","","A common grammar symbol type.",null,null],[0,"binarized","","Binarized rules are rules that have at most two symbols on the right-hand side.\nA binarized grammar contains only such rules.",null,null],[3,"BinarizedCfg","cfg::binarized","Representation for grammars where right-hand sides of all rules have at most two symbols.",null,null],[3,"BinarizedRule","","Compact representation of a binarized rule.",null,null],[3,"BinarizedRuleToRuleRef","","A wrapper for iteration over rule refs.",null,null],[3,"LhsWithHistoryToRuleRef","","A wrapper for iteration over rule refs.",null,null],[4,"BinarizedRuleRhs","","Compact representation of a binarized rule&#39;s RHS.",null,null],[13,"One","","RHS with one symbol.",0,null],[13,"Two","","RHS with two symbols.",0,null],[6,"BinarizedRules","","Iterator over binarized rules.",null,null],[6,"LhsWithHistory","","A type for iteration over rule refs.",null,null],[11,"clone","","",1,null],[11,"clone","","",2,null],[11,"partial_cmp","","",0,null],[11,"lt","","",0,null],[11,"le","","",0,null],[11,"gt","","",0,null],[11,"ge","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"cmp","","",0,null],[11,"clone","","",0,null],[11,"new","","Creates a BinarizedCfg.",1,{"inputs":[],"output":{"name":"self"}}],[11,"with_sym_source","","Creates an empty BinarizedCfg with the given symbol source.",1,{"inputs":[{"name":"symbolsource"}],"output":{"name":"self"}}],[11,"from_context_free","","Creates a BinarizedCfg by binarizing a context-free grammar.",1,{"inputs":[{"name":"g"}],"output":{"name":"binarizedcfg"}}],[11,"sort","","Sorts the rule array.",1,null],[11,"sort_by","","Sorts the rule array in place, using the argument to compare elements.",1,null],[11,"dedup","","Removes consecutive duplicate rules.",1,null],[11,"sym","","Returns generated symbols.",1,null],[11,"next_sym","","Generates a new unique symbol.",1,null],[11,"num_syms","","Returns the number of symbols in use.",1,null],[11,"eliminate_nulling_rules","","Eliminates all rules of the form `A ::= epsilon`.",1,null],[11,"sym_source","","",1,null],[11,"sym_source_mut","","",1,null],[11,"retain","","",1,null],[11,"add_rule","","",1,null],[11,"lhs","","",2,null],[11,"rhs","","",2,null],[11,"history","","",2,null],[11,"new","","Creates a new binarized rule.",2,null],[11,"rhs0","","Returns the first symbol.",2,null],[11,"rhs1","","Returns the second symbol, if present.",2,null],[11,"eq","","",2,null],[11,"partial_cmp","","",2,null],[11,"cmp","","",2,null],[11,"new","","Creates a new BinarizedRuleToRuleRef.",3,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"next","","",3,null],[11,"size_hint","","",3,null],[11,"new","","Creates a new LhsWithHistoryToRuleRef.",4,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"next","","",4,null],[11,"size_hint","","",4,null],[0,"cycles","cfg","Cycle detection and elimination.",null,null],[3,"Cycles","cfg::cycles","Provides information about cycles among unit derivations in the grammar. There are two ways of\npruning cycles.",null,null],[3,"CycleParticipants","","An iterator over the grammar&#39;s useless rules.",null,null],[11,"new","","Analyzes the grammar&#39;s cycles.",5,{"inputs":[{"name":"g"}],"output":{"name":"cycles"}}],[11,"cycle_free","","Checks whether the grammar is cycle-free.",5,null],[11,"cycle_participants","","Iterates over rules that participate in a cycle.",5,null],[11,"remove_cycles","","Removes all rules that participate in a cycle. Doesn&#39;t preserve the language represented\nby the grammar.",5,null],[11,"rewrite_cycles","","Rewrites all rules that participate in a cycle. Preserves the language represented\nby the grammar.",5,null],[11,"next","","",6,null],[11,"clone","cfg","",7,null],[11,"new","","Creates an empty context-free grammar.",7,{"inputs":[],"output":{"name":"self"}}],[11,"with_sym_source","","Creates an empty context-free grammar with the given symbol source.",7,{"inputs":[{"name":"symbolsource"}],"output":{"name":"self"}}],[11,"sym","","Returns generated symbols.",7,null],[11,"next_sym","","Generates a new unique symbol.",7,null],[11,"num_syms","","Returns the number of symbols in use.",7,null],[11,"sequence","","Starts building a sequence rule.",7,null],[11,"sequence_rules","","Returns sequence rules.",7,null],[11,"rewrite_sequences","","Forces a rewrite of sequence rules into grammar rules.",7,null],[11,"binarize","","Returns a binarized grammar which is weakly equivalent to this grammar.",7,null],[11,"sym_source","","",7,null],[11,"sym_source_mut","","",7,null],[11,"retain","","",7,null],[11,"add_rule","","",7,null],[0,"history","","Any data carried alongside a grammar rule can be its _history_. Rule histories may contain\nmore than semantic actions.",null,null],[3,"NullHistory","cfg::history","A history which carries no data. All operations on `NullHistory` are no-op.",null,null],[3,"CloneHistory","","Clone history.",null,null],[3,"DefaultHistory","","Factory of default histories.",null,null],[3,"NullHistorySource","","A source that only works for building NullHistory.",null,null],[4,"BinarizedRhsSubset","","Used to inform which symbols on a rule&#39;Symbol RHS are nullable, and will be eliminated.",null,null],[13,"Left","","The first of two symbols.",8,null],[13,"Right","","The second of two symbols.",8,null],[13,"All","","All 1 or 2 symbols. The rule is nullable.",8,null],[8,"Action","","Trait for history types that may have semantic actions.",null,null],[10,"no_op","","Returns a history with no-op semantic action.",9,null],[8,"Binarize","","Trait for history types that allow the rule to be binarized.",null,null],[10,"binarize","","Returns a history. May record the binarization.",10,null],[8,"EliminateNulling","","Trait for history types that allow the rule to have nulling symbols\neliminated from the RHS.",null,null],[10,"eliminate_nulling","","Returns a history. May record the elimination.",11,null],[8,"AssignPrecedence","","Trait for history types that allow the rule to have its precedence assigned.",null,null],[10,"assign_precedence","","Returns a history. May record the precedence.",12,null],[8,"RewriteSequence","","Trait for history types that allow the sequence rule to be rewritten into grammar rules.",null,null],[16,"Rewritten","","Must be an `Action`, because all created grammar rules except the topmost one will have\nno-op semantic action.",13,null],[10,"top","","Returns a history. May record the rewrite.",13,null],[10,"bottom","","Returns a history. May record the rewrite.",13,null],[8,"HistorySource","","A trait for history factories.",null,null],[10,"build","","Create a history.",14,null],[11,"clone","","",8,null],[11,"default","","",15,{"inputs":[],"output":{"name":"nullhistory"}}],[11,"fmt","","",15,null],[11,"clone","","",15,null],[11,"no_op","","",15,null],[11,"binarize","","",15,null],[11,"eliminate_nulling","","",15,null],[11,"assign_precedence","","",15,null],[11,"top","","",15,null],[11,"bottom","","",15,null],[11,"new","","Creates a cloned history factory.",16,{"inputs":[{"name":"h"}],"output":{"name":"self"}}],[11,"build","","",16,null],[11,"new","","Creates a default history factory.",17,{"inputs":[],"output":{"name":"self"}}],[11,"build","","",17,null],[11,"clone","","",18,null],[11,"build","","",18,null],[0,"precedence","cfg","Precedenced rules are built with the builder pattern.",null,null],[3,"PrecedencedRuleBuilder","cfg::precedence","Precedenced rules are built in series of rule alternatives with equal precedence.",null,null],[4,"Associativity","","Specifies the associativity of an operator.",null,null],[13,"Left","","Left associative.",19,null],[13,"Right","","Right associative.",19,null],[13,"Group","","`Group` usually means the operand is delimited, e.g. by parentheses.",19,null],[11,"eq","","",19,null],[11,"clone","","",19,null],[11,"new","","Returns a precedenced rule builder.",20,{"inputs":[{"name":"d"},{"name":"symbol"}],"output":{"name":"self"}}],[11,"default_history","","Sets the default history source.",20,null],[11,"precedenced_rule","","Starts building a new precedenced rule. The differences in precedence among rules only\nmatter within a particular precedenced rule.",20,null],[11,"rule","","Starts building a new grammar rule.",20,null],[11,"history","","Assigns the rule history, which is used on the next call to `rhs`, unless overwritten by\na call to `rhs_with_history`.",20,null],[11,"rhs","","Creates a rule alternative. If history wasn&#39;t provided, the rule has the `Default` history.",20,null],[11,"rhs_with_history","","Creates a rule alternative with the given RHS and history.",20,null],[11,"associativity","","Assigns the associativity, which influences the next call to `rhs` or `rhs_with_history`.",20,null],[11,"lower_precedence","","Assigns lower precedence to rule alternatives that are built after this call.",20,null],[11,"drop","","",20,null],[0,"prediction","cfg","Prediction for predictive parsers.",null,null],[3,"MinimalDistance","cfg::prediction","Calculation of minimum distance from one part of the grammar to another.\nSimilar to multi-source shortest path search in a graph.",null,null],[3,"FirstSets","","FIRST sets.",null,null],[3,"FollowSets","","FOLLOW sets.",null,null],[11,"new","","Returns a new `MinimalDistance` for a grammar.",21,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"distances","","Returns distances in order respective to the order of rule iteration.",21,null],[11,"minimal_distances","","Calculates minimal distance from one parts of the grammar to others.\nReturns distances in order respective to the order of rule iteration.",21,null],[11,"new","","Compute all FIRST sets of the grammar.",22,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"first_sets","","Returns a reference to FIRST sets.",22,null],[11,"new","","Compute all FOLLOW sets of the grammar.\nReturns FollowSets.",23,{"inputs":[{"name":"g"},{"name":"symbol"},{"name":"firstsets"}],"output":{"name":"self"}}],[11,"follow_sets","","Returns a reference to FOLLOW sets.",23,null],[6,"PerSymbolSets","","The representation of FIRST and FOLLOW sets.",null,null],[0,"remap","cfg","Remaps symbols and removes unused symbols.",null,null],[3,"Remap","cfg::remap","Remaps symbols and removes unused symbols.",null,null],[3,"Mapping","","Contains maps for translation between internal and external symbols.",null,null],[12,"to_internal","","An array of internal symbols, indexed by external symbol ID.",24,null],[12,"to_external","","An array of external symbols, indexed by internal symbol ID.",24,null],[11,"new","","Creates `Remap` to record information about remapped symbols.",25,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"remove_unused_symbols","","Removes unused symbols.",25,null],[11,"reorder_symbols","","Remaps symbols to satisfy given ordering constraints. The argument\nmust be a function that gives total order.",25,null],[11,"get_mapping","","Get the mapping.",25,null],[11,"new","","Creates a new instance of `Mapping`.",24,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"translate","","Translates symbols in this map using another symbol map.\nThis map becomes a combination of both mappings.",24,null],[0,"rule","cfg","This module defines grammar rules. Each rule in a context-free grammar\nconsists of a single symbol on its left-hand side and an array of symbols\non its right-hand side. In this library, each rule carries additional\nvalue called &quot;history.&quot;",null,null],[3,"Rule","cfg::rule","Typical grammar rule representation.",null,null],[12,"rhs","","The rule&#39;s right-hand side.",26,null],[12,"history","","The rule&#39;s history.",26,null],[3,"RuleRef","","References rule&#39;s components.",null,null],[12,"lhs","","Left-hand side.",27,null],[12,"rhs","","Right-hand side.",27,null],[12,"history","","The rule&#39;s history.",27,null],[0,"builder","","Grammar rules can be built with the builder pattern.",null,null],[3,"RuleBuilder","cfg::rule::builder","The rule builder.",null,null],[11,"new","","Creates a rule builder.",28,{"inputs":[{"name":"c"}],"output":{"name":"rulebuilder"}}],[11,"default_history","","Sets the default history source.",28,null],[11,"rule","","Starts building a new rule with the given LHS.",28,null],[11,"history","","Assigns the rule history, which is used on the next call to `rhs`, or overwritten by a call\nto`rhs_with_history`.",28,null],[11,"rhs","","Adds a rule alternative to the grammar. If history wasn&#39;t provided, the rule has the\n`Default` history.",28,null],[11,"rhs_with_history","","Adds a rule alternative with the given RHS and history to the grammar.",28,null],[11,"precedenced_rule","","Starts building a new precedenced rule.",28,null],[0,"container","cfg::rule","Abstraction for collections of rules.",null,null],[8,"RuleContainer","cfg::rule::container","Trait for rule and symbol containers.",null,null],[16,"History","","The type of history carried with the rule.",29,null],[10,"sym_source","","Returns an immutable reference to the grammar&#39;s symbol source.",29,null],[10,"sym_source_mut","","Returns a mutable reference to the grammar&#39;s symbol source.",29,null],[11,"sym","","Returns generated symbols.",29,null],[11,"next_sym","","Generates a new unique symbol.",29,null],[11,"num_syms","","Returns the number of symbols in use.",29,null],[10,"retain","","Retains only the rules specified by the predicate.",29,null],[10,"add_rule","","Inserts a rule with `lhs` and `rhs` on its LHS and RHS. The rule carries `history`.",29,null],[8,"GrammarRule","cfg::rule","Trait for rules of a context-free grammar.",null,null],[16,"History","","The type of history carried with the rule.",30,null],[10,"lhs","","Returns the rule&#39;s left-hand side.",30,null],[10,"rhs","","Returns the rule&#39;s right-hand side.",30,null],[10,"history","","Returns a reference to the history carried with the rule.",30,null],[11,"fmt","","",26,null],[11,"clone","","",26,null],[11,"lhs","","",26,null],[11,"rhs","","",26,null],[11,"history","","",26,null],[11,"new","","Creates a new rule.",26,{"inputs":[{"name":"symbol"},{"name":"vec"},{"name":"h"}],"output":{"name":"self"}}],[11,"clone","","",27,null],[11,"lhs","","",27,null],[11,"rhs","","",27,null],[11,"history","","",27,null],[0,"sequence","cfg","Sequences are similar to regex repetitions with numbering.",null,null],[3,"Sequence","cfg::sequence","Sequence rule representation.",null,null],[12,"lhs","","The rule&#39;s left-hand side.",31,null],[12,"rhs","","The rule&#39;s right-hand side.",31,null],[12,"start","","The minimum number of repetitions.",31,null],[12,"end","","Either the inclusive maximum number of repetitions, or `None` if the number of repetitions\nis unlimited.",31,null],[12,"separator","","The way elements are separated in a sequence, or `Null`.",31,null],[12,"history","","The history carried with the sequence rule.",31,null],[4,"Separator","","The separator symbol and mode of separation in a sequence, or `Null` for no separation.",null,null],[13,"Trailing","","Separation with the trailing separator included. In other words, all elements are followed\nby the separator.",32,null],[13,"Proper","","The separator occurs between elements.",32,null],[13,"Liberal","","The union of `Trailing` and `Proper`. In other words, the trailing separator may or may not\nbe present.",32,null],[13,"Null","","No separation.",32,null],[0,"builder","","Sequence rules can be built with the builder pattern.",null,null],[3,"SequenceRuleBuilder","cfg::sequence::builder","Sequence rule builder.",null,null],[11,"new","","Creates a sequence rule builder.",33,{"inputs":[{"name":"d"}],"output":{"name":"self"}}],[11,"default_history","","Sets the default history source.",33,null],[11,"sequence","","Starts building a sequence rule.",33,null],[11,"separator","","Assigns the separator symbol and mode of separation.",33,null],[11,"intersperse","","Sets proper separation with the given separator symbol.",33,null],[11,"history","","Assigns the rule history, which is used on the next call to `rhs`, or overwritten by a call\nto `rhs_with_history`.",33,null],[11,"inclusive","","Assigns the inclusive range of the number of repetitions.",33,null],[11,"rhs","","Adds a sequence rule to the grammar.",33,null],[11,"rhs_with_history","","Adds a sequence rule to the grammar.",33,null],[0,"destination","cfg::sequence","Sequence destination.",null,null],[8,"SequenceDestination","cfg::sequence::destination","Trait for storing sequence rules in containers, with potential rewrites.",null,null],[10,"add_sequence","","Inserts a sequence rule.",34,null],[0,"rewrite","cfg::sequence","Rewrites sequence rules into production rules.",null,null],[3,"SequencesToProductions","cfg::sequence::rewrite","Rewrites sequence rules into production rules.",null,null],[11,"add_sequence","","",35,null],[11,"new","","Initializes a rewrite.",35,{"inputs":[{"name":"d"}],"output":{"name":"self"}}],[11,"rewrite_sequences","","Rewrites sequence rules.",35,null],[11,"rewrite","","Rewrites a sequence rule.",35,null],[11,"eq","cfg::sequence","",31,null],[11,"ne","","",31,null],[11,"hash","","",31,null],[11,"fmt","","",31,null],[11,"clone","","",31,null],[11,"eq","","",32,null],[11,"ne","","",32,null],[11,"hash","","",32,null],[11,"fmt","","",32,null],[11,"clone","","",32,null],[11,"inclusive","","Assigns the inclusive range of the number of repetitions.",31,null],[11,"separator","","Assigns the separator symbol and mode of separation.",31,null],[11,"prefix_separator","","Returns the kind of separation for a prefix sequence.",32,null],[11,"into","","",32,null],[0,"symbol","cfg","A type that can represent symbols in a context-free grammar. Symbols are distinguished by their\nIDs.",null,null],[3,"Symbol","cfg::symbol","A common grammar symbol type.",null,null],[11,"partial_cmp","cfg","",36,null],[11,"lt","","",36,null],[11,"le","","",36,null],[11,"gt","","",36,null],[11,"ge","","",36,null],[11,"eq","","",36,null],[11,"ne","","",36,null],[11,"cmp","","",36,null],[11,"hash","","",36,null],[11,"fmt","","",36,null],[11,"clone","","",36,null],[11,"from","","",36,{"inputs":[{"name":"symbolrepr"}],"output":{"name":"self"}}],[11,"into","","",36,null],[0,"set","cfg::symbol","Informs whether symbols are terminal or nonterminal.",null,null],[3,"SymbolBitSet","cfg::symbol::set","A set of symbols in the form of a bit vector.",null,null],[3,"Iter","","An iterator over a symbol set.",null,null],[11,"new","","Constructs a `SymbolBitSet`.",37,{"inputs":[{"name":"g"},{"name":"bool"}],"output":{"name":"self"}}],[11,"terminal_set","","Gathers information about whether symbols are terminal or nonterminal.\nConstructs a set of terminal symbols.",37,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"has_sym","","Checks whether a given symbol is in this set.",37,null],[11,"into_bit_vec","","Converts into a bit vector.",37,null],[11,"iter","","Iterates over symbols in the set.",37,null],[11,"next","","",38,null],[0,"source","cfg::symbol","Source",null,null],[3,"SymbolSource","cfg::symbol::source","A source of numeric symbols.",null,null],[3,"Generate","","Iterator for generating symbols.",null,null],[8,"SymbolContainer","","Trait used to generate symbols.",null,null],[10,"generate","","Generates symbols.",39,{"inputs":[{"name":"symbolsource"}],"output":{"name":"self"}}],[11,"fmt","","",40,null],[11,"clone","","",40,null],[11,"new","","Creates a source of numeric symbols with an empty symbol space.",40,{"inputs":[],"output":{"name":"self"}}],[11,"sym","","Returns generated symbols.",40,null],[11,"next_sym","","Generates a new unique symbol.",40,null],[11,"num_syms","","Returns the number of symbols in use.",40,null],[11,"generate","","Returns an iterator that generates symbols.",40,null],[11,"generate","cfg","",36,{"inputs":[{"name":"symbolsource"}],"output":{"name":"self"}}],[11,"next","cfg::symbol::source","",41,null],[11,"usize","cfg","Cast the symbol&#39;s ID to `usize`.",36,null],[11,"from","","",36,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"into","","",36,null],[0,"usefulness","","Analysis of rule usefulness.",null,null],[3,"Usefulness","cfg::usefulness","Contains the information about usefulness of the grammar&#39;s rules.\nUseful rules are both reachable and productive.",null,null],[3,"UselessRules","","An iterator over the grammar&#39;s useless rules.",null,null],[3,"UselessRule","","A reference to a useless rule, together with the reason for its uselessness.",null,null],[12,"rule","","Reference to a rule.",42,null],[12,"unreachable","","Indicates whether the rule is unreachable.",42,null],[12,"unproductive","","Indicates whether the rule is unproductive.",42,null],[11,"fmt","","",42,null],[11,"clone","","",42,null],[11,"new","","Analyzes usefulness of the grammar&#39;s rules. In particular, it checks for reachable\nand productive symbols.",43,{"inputs":[{"name":"g"}],"output":{"name":"usefulness"}}],[11,"productivity","","Checks whether a symbol is productive. Can be used to determine the precise reason\nof a rule&#39;s unproductiveness.",43,null],[11,"reachable","","Sets symbol reachability. Takes an array of reachable symbols.",43,null],[11,"all_useful","","Checks whether all rules in the grammar are useful.",43,null],[11,"all_productive","","Checks whether all rules in the grammar are productive.",43,null],[11,"useless_rules","","Returns an iterator over the grammar&#39;s useless rules.",43,null],[11,"remove_useless_rules","","Removes useless rules. The language represented by the grammar doesn&#39;t change.",43,null],[11,"next","","",44,null],[8,"ContextFree","cfg","Trait for context-free grammars.",null,null],[11,"rule","","Starts building a new rule.",45,null],[11,"precedenced_rule","","Starts building a new precedenced rule.",45,null],[8,"ContextFreeRef","","This trait is currently needed to make the associated `Rules` iterator generic over a lifetime\nparameter.",null,null],[16,"RuleRef","","Immutable reference to a rule.",46,null],[16,"Rules","","Iterator over immutable references to the grammar&#39;s rules.",46,null],[10,"rules","","Returns an iterator over immutable references to the grammar&#39;s rules.",46,null],[8,"ContextFreeMut","","Allows access to a ContextFreeRef through mutable references.",null,null],[11,"rule","","Starts building a new rule.",45,null],[11,"precedenced_rule","","Starts building a new precedenced rule.",45,null]],"paths":[[4,"BinarizedRuleRhs"],[3,"BinarizedCfg"],[3,"BinarizedRule"],[3,"BinarizedRuleToRuleRef"],[3,"LhsWithHistoryToRuleRef"],[3,"Cycles"],[3,"CycleParticipants"],[3,"Cfg"],[4,"BinarizedRhsSubset"],[8,"Action"],[8,"Binarize"],[8,"EliminateNulling"],[8,"AssignPrecedence"],[8,"RewriteSequence"],[8,"HistorySource"],[3,"NullHistory"],[3,"CloneHistory"],[3,"DefaultHistory"],[3,"NullHistorySource"],[4,"Associativity"],[3,"PrecedencedRuleBuilder"],[3,"MinimalDistance"],[3,"FirstSets"],[3,"FollowSets"],[3,"Mapping"],[3,"Remap"],[3,"Rule"],[3,"RuleRef"],[3,"RuleBuilder"],[8,"RuleContainer"],[8,"GrammarRule"],[3,"Sequence"],[4,"Separator"],[3,"SequenceRuleBuilder"],[8,"SequenceDestination"],[3,"SequencesToProductions"],[3,"Symbol"],[3,"SymbolBitSet"],[3,"Iter"],[8,"SymbolContainer"],[3,"SymbolSource"],[3,"Generate"],[3,"UselessRule"],[3,"Usefulness"],[3,"UselessRules"],[8,"ContextFree"],[8,"ContextFreeRef"]]};
searchIndex["bit_matrix"] = {"doc":"Implements bit matrices.","items":[[0,"matrix","bit_matrix","Matrix of bits.",null,null],[3,"BitMatrix","bit_matrix::matrix","A matrix of bits.",null,null],[11,"hash","","",0,null],[11,"cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"lt","","",0,null],[11,"le","","",0,null],[11,"gt","","",0,null],[11,"ge","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"new","","Create a new BitMatrix with specific numbers of bits in columns and rows.",0,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"size","","Returns the matrix&#39;s size as `(rows, columns)`.",0,null],[11,"set","","Sets the value of a bit.",0,null],[11,"grow","","Grows the matrix in-place, adding `num_rows` rows filled with `value`.",0,null],[11,"sub_matrix","","Returns a slice of the matrix&#39;s rows.",0,null],[11,"split_at","","Given a row&#39;s index, returns a slice of all rows above that row, a reference to said row,\nand a slice of all rows below.",0,null],[11,"split_at_mut","","Given a row&#39;s index, returns a slice of all rows above that row, a reference to said row,\nand a slice of all rows below.",0,null],[11,"iter_row","","Iterate over bits in the specified row.",0,null],[11,"transitive_closure","","Computes the transitive closure of the binary relation represented by the matrix.",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"index","","",0,null],[0,"row","bit_matrix","Implements access to a matrix&#39;s individual rows.",null,null],[3,"BitVecSlice","bit_matrix::row","A slice of bit vector&#39;s blocks.",null,null],[3,"Iter","","An iterator for `BitVecSlice`.",null,null],[11,"new","","Creates a new slice from a slice of blocks.",1,null],[11,"iter_bits","","Iterates over bits.",1,null],[11,"get","","Returns `true` if a bit is enabled in the bit vector slice, or `false` otherwise.",1,null],[11,"index","","",1,null],[11,"deref","","",1,null],[11,"deref_mut","","",1,null],[11,"clone","","",2,null],[11,"next","","",2,null],[11,"size_hint","","",2,null],[0,"submatrix","bit_matrix","Submatrix of bits.",null,null],[3,"BitSubMatrix","bit_matrix::submatrix","Immutable access to a range of matrix&#39;s rows.",null,null],[3,"BitSubMatrixMut","","Mutable access to a range of matrix&#39;s rows.",null,null],[11,"new","","Returns a new BitSubMatrix.",3,null],[11,"from_raw_parts","","Forms a BitSubMatrix from a pointer and dimensions.",3,null],[11,"iter","","Iterates over the matrix&#39;s rows in the form of mutable slices.",3,null],[11,"new","","Returns a new BitSubMatrixMut.",4,null],[11,"from_raw_parts","","Forms a BitSubMatrix from a pointer and dimensions.",4,null],[11,"set","","Sets the value of a bit.",4,null],[11,"sub_matrix","","Returns a slice of the matrix&#39;s rows.",4,null],[11,"split_at","","Given a row&#39;s index, returns a slice of all rows above that row, a reference to said row,\nand a slice of all rows below.",4,null],[11,"split_at_mut","","Given a row&#39;s index, returns a slice of all rows above that row, a reference to said row,\nand a slice of all rows below.",4,null],[11,"transitive_closure","","Computes the transitive closure of the binary relation represented by the matrix.",4,null],[11,"iter_mut","","Iterates over the matrix&#39;s rows in the form of mutable slices.",4,null],[11,"index","","",4,null],[11,"index_mut","","",4,null],[11,"index","","",3,null],[11,"fmt","","",3,null],[6,"Block","bit_matrix","The type for storing bits.",null,null],[7,"TRUE","","A value for borrowing.",null,null],[7,"FALSE","","A value for borrowing.",null,null],[17,"BITS","","The number of bits in a block.",null,null]],"paths":[[3,"BitMatrix"],[3,"BitVecSlice"],[3,"Iter"],[3,"BitSubMatrix"],[3,"BitSubMatrixMut"]]};
searchIndex["bit_vec"] = {"doc":"Collections implemented with bit vectors.","items":[[3,"BitVec","bit_vec","The bitvector type.",null,null],[3,"Iter","","An iterator for `BitVec`.",null,null],[3,"IntoIter","","",null,null],[3,"Blocks","","An iterator over the blocks of a `BitVec`.",null,null],[8,"BitBlock","","Abstracts over a pile of bits (basically unsigned primitives)",null,null],[10,"bits","","How many bits it has",0,{"inputs":[],"output":{"name":"usize"}}],[11,"bytes","","How many bytes it has",0,{"inputs":[],"output":{"name":"usize"}}],[10,"from_byte","","Convert a byte into this type (lowest-order bits set)",0,{"inputs":[{"name":"u8"}],"output":{"name":"self"}}],[10,"count_ones","","Count the number of 1&#39;s in the bitwise repr",0,null],[10,"zero","","Get `0`",0,{"inputs":[],"output":{"name":"self"}}],[10,"one","","Get `1`",0,{"inputs":[],"output":{"name":"self"}}],[11,"index","","",1,null],[11,"new","","Creates an empty `BitVec`.",1,{"inputs":[],"output":{"name":"self"}}],[11,"from_elem","","Creates a `BitVec` that holds `nbits` elements, setting each element\nto `bit`.",1,{"inputs":[{"name":"usize"},{"name":"bool"}],"output":{"name":"self"}}],[11,"with_capacity","","Constructs a new, empty `BitVec` with the specified capacity.",1,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"from_bytes","","Transforms a byte-vector into a `BitVec`. Each byte becomes eight bits,\nwith the most significant bits of each byte coming first. Each\nbit becomes `true` if equal to 1 or `false` if equal to 0.",1,null],[11,"from_fn","","Creates a `BitVec` of the specified length where the value at each index\nis `f(index)`.",1,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"self"}}],[11,"blocks","","Iterator over the underlying blocks of data",1,null],[11,"storage","","Exposes the raw block storage of this BitVec",1,null],[11,"storage_mut","","Exposes the raw block storage of this BitVec",1,null],[11,"get","","Retrieves the value at index `i`, or `None` if the index is out of bounds.",1,null],[11,"set","","Sets the value of a bit at an index `i`.",1,null],[11,"set_all","","Sets all bits to 1.",1,null],[11,"negate","","Flips all bits.",1,null],[11,"union","","Calculates the union of two bitvectors. This acts like the bitwise `or`\nfunction.",1,null],[11,"intersect","","Calculates the intersection of two bitvectors. This acts like the\nbitwise `and` function.",1,null],[11,"difference","","Calculates the difference between two bitvectors.",1,null],[11,"all","","Returns `true` if all bits are 1.",1,null],[11,"iter","","Returns an iterator over the elements of the vector in order.",1,null],[11,"none","","Returns `true` if all bits are 0.",1,null],[11,"any","","Returns `true` if any bit is 1.",1,null],[11,"to_bytes","","Organises the bits into bytes, such that the first bit in the\n`BitVec` becomes the high-order bit of the first byte. If the\nsize of the `BitVec` is not a multiple of eight then trailing bits\nwill be filled-in with `false`.",1,null],[11,"eq_vec","","Compares a `BitVec` to a slice of `bool`s.\nBoth the `BitVec` and slice must have the same length.",1,null],[11,"truncate","","Shortens a `BitVec`, dropping excess elements.",1,null],[11,"reserve","","Reserves capacity for at least `additional` more bits to be inserted in the given\n`BitVec`. The collection may reserve more space to avoid frequent reallocations.",1,null],[11,"reserve_exact","","Reserves the minimum capacity for exactly `additional` more bits to be inserted in the\ngiven `BitVec`. Does nothing if the capacity is already sufficient.",1,null],[11,"capacity","","Returns the capacity in bits for this bit vector. Inserting any\nelement less than this amount will not trigger a resizing.",1,null],[11,"grow","","Grows the `BitVec` in-place, adding `n` copies of `value` to the `BitVec`.",1,null],[11,"pop","","Removes the last bit from the BitVec, and returns it. Returns None if the BitVec is empty.",1,null],[11,"push","","Pushes a `bool` onto the end.",1,null],[11,"len","","Returns the total number of bits in this vector",1,null],[11,"set_len","","Sets the number of bits that this BitVec considers initialized.",1,null],[11,"is_empty","","Returns true if there are no bits in this vector",1,null],[11,"clear","","Clears all bits in this vector.",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"from_iter","","",1,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend","","",1,null],[11,"clone","","",1,null],[11,"clone_from","","",1,null],[11,"partial_cmp","","",1,null],[11,"cmp","","",1,null],[11,"fmt","","",1,null],[11,"hash","","",1,null],[11,"eq","","",1,null],[11,"clone","","",2,null],[11,"next","","",2,null],[11,"size_hint","","",2,null],[11,"next_back","","",2,null],[11,"next","","",3,null],[11,"next_back","","",3,null],[11,"into_iter","","",1,null],[11,"clone","","",4,null],[11,"next","","",4,null],[11,"size_hint","","",4,null],[11,"next_back","","",4,null]],"paths":[[8,"BitBlock"],[3,"BitVec"],[3,"Iter"],[3,"IntoIter"],[3,"Blocks"]]};
initSearch(searchIndex);
